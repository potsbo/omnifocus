import { exec } from "child_process";
import { promisify } from "util";
import { parseStringPromise } from "xml2js";
import fs from "fs";
import {
  print,
  lexicographicSortSchema,
  printSchema,
  buildASTSchema,
  DocumentNode,
  DefinitionNode,
} from "graphql";
import { join } from "path";
import { pruneSchema } from "@graphql-tools/utils";
import { Sdef } from "./sdef";
import { ConnectionInterface, EdgeInterface, NodeInterface } from "./constants";
import prettier from "prettier";
import gql from "graphql-tag";
import { prune } from "./prune";
import { parseSuites } from "./suite";

const getRenderers = async (appPath: string) => {
  const sdefCmdResult = await promisify(exec)(`sdef ${appPath}`);
  const sdef = (await parseStringPromise(sdefCmdResult.stdout)) as Sdef;
  return parseSuites(sdef);
};

(async (appPath: string, override?: DocumentNode) => {
  const renderers = await getRenderers(appPath);

  const env = { ...renderers, override };
  const renderList = [
    ...renderers.classRenderers,
    ...renderers.enumRenderers,
    ...renderers.recordTypeRenderers,
    ...renderers.extensionRenderers,
  ];

  const definitions: DefinitionNode[] = [ConnectionInterface, EdgeInterface, NodeInterface];
  renderList.forEach((cdef) => {
    definitions.push(...cdef.build(env));
  });

  const schema = gql`
    type Query {
      application: Application!
    }
    type Mutation

    ${definitions.map(print).join("\n")}

    # https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
    type PageInfo {
      hasPreviousPage: Boolean!
      hasNextPage: Boolean!
      startCursor: String!
      endCursor: String!
    }

    directive @recordType on OBJECT

    input Condition {
      enabled: Boolean! = true
      field: String
      operands: [Condition!]
      operator: String! = "="
      value: String! = "true"
    }

    ${override ? print(override) : ""}
  `;

  const path = join(__dirname, "..", "..", "..", "assets", "schema.graphql");

  const sorted = lexicographicSortSchema(pruneSchema(buildASTSchema(prune(schema))));
  const sortedSchema = printSchema(sorted);
  const comment = `# Code generated by "sdef-to-schema"; DO NOT EDIT.\n`;

  fs.writeFile(path, prettier.format(comment + sortedSchema, { parser: "graphql" }), (err) => {
    if (err) {
      throw err;
    }
    console.log(`âœ… Schemad generated`);
  });
})(
  "/Applications/OmniFocus.app",
  gql`
    scalar RichText
  `
).catch((err) => {
  console.error(err);
});
