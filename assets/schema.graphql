# Code generated by "sdef-to-schema"; DO NOT EDIT.
directive @whose(condition: [Condition!]!) on FIELD

input Condition {
  enabled: Boolean! = true
  field: String
  operands: [Condition!]
  operator: String! = "="
  value: String! = "true"
}

interface Connection {
  byId(id: String!): Node
  edges: [Edge!]!
  pageInfo: PageInfo!
}

type Document implements Node {
  canRedo: Boolean!
  canUndo: Boolean!
  compressesTransactions: Boolean!
  disableAutomaticInboxCleanup: Boolean!
  flattenedTasks: FlattenedTaskConnection!
  folders: FolderConnection!
  id: String!
  inboxTasks: InboxTaskConnection!
  includesSummaries: Boolean!
  lastSyncDate: String!
  lastSyncError: String!
  modified: Boolean!
  name: String!
  path: String!
  perspectiveNames: [String!]!
  projects: ProjectConnection!
  sections: SectionConnection!
  syncing: Boolean!
  tags: TagConnection!
  tasks: TaskConnection!
  willAutosave: Boolean!
}

type DocumentConnection implements Connection {
  byId(id: String!): Document
  edges: [DocumentEdge!]!
  pageInfo: PageInfo!
}

type DocumentEdge implements Edge {
  cursor: String!
  node: Document!
}

interface Edge {
  cursor: String!
  node: Node!
}

type FlattenedTask implements Node & TaskInterface {
  blocked: Boolean!
  completed: Boolean!
  completedByChildren: Boolean!
  completionDate: String
  containingProject: Project
  creationDate: String!
  deferDate: String
  dropped: Boolean!
  droppedDate: String
  dueDate: String
  effectiveDeferDate: String
  effectiveDueDate: String
  effectivelyCompleted: Boolean!
  effectivelyDropped: Boolean!
  estimatedMinutes: Int
  flagged: Boolean!
  flattenedTasks: FlattenedTaskConnection!
  id: String!
  inInbox: Boolean!
  modificationDate: String!
  name: String!
  next: Boolean!
  nextDeferDate: String
  nextDueDate: String
  numberOfAvailableTasks: Int!
  numberOfCompletedTasks: Int!
  numberOfTasks: Int!
  parentTask: Task
  primaryTag: Tag
  sequential: Boolean!
  shouldUseFloatingTimeZone: Boolean!
  tags: TagConnection!
  tasks: TaskConnection!
}

type FlattenedTaskConnection implements Connection {
  byId(id: String!): FlattenedTask
  edges: [FlattenedTaskEdge!]!
  pageInfo: PageInfo!
}

type FlattenedTaskEdge implements Edge {
  cursor: String!
  node: FlattenedTask!
}

type Folder implements Node {
  creationDate: String!
  effectivelyHidden: Boolean!
  folders: FolderConnection!
  hidden: Boolean!
  id: String!
  modificationDate: String!
  name: String!
  projects: ProjectConnection!
  sections: SectionConnection!
}

type FolderConnection implements Connection {
  byId(id: String!): Folder
  edges: [FolderEdge!]!
  pageInfo: PageInfo!
}

type FolderEdge implements Edge {
  cursor: String!
  node: Folder!
}

type InboxTask implements Node & TaskInterface {
  blocked: Boolean!
  completed: Boolean!
  completedByChildren: Boolean!
  completionDate: String
  containingProject: Project
  creationDate: String!
  deferDate: String
  dropped: Boolean!
  droppedDate: String
  dueDate: String
  effectiveDeferDate: String
  effectiveDueDate: String
  effectivelyCompleted: Boolean!
  effectivelyDropped: Boolean!
  estimatedMinutes: Int
  flagged: Boolean!
  flattenedTasks: FlattenedTaskConnection!
  id: String!
  inInbox: Boolean!
  modificationDate: String!
  name: String!
  next: Boolean!
  nextDeferDate: String
  nextDueDate: String
  numberOfAvailableTasks: Int!
  numberOfCompletedTasks: Int!
  numberOfTasks: Int!
  parentTask: Task
  primaryTag: Tag
  sequential: Boolean!
  shouldUseFloatingTimeZone: Boolean!
  tags: TagConnection!
  tasks: TaskConnection!
}

type InboxTaskConnection implements Connection {
  byId(id: String!): InboxTask
  edges: [InboxTaskEdge!]!
  pageInfo: PageInfo!
}

type InboxTaskEdge implements Edge {
  cursor: String!
  node: InboxTask!
}

interface Node {
  id: String!
}

type PageInfo {
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
}

type Project implements Node {
  blocked: Boolean!
  completed: Boolean!
  completedByChildren: Boolean!
  completionDate: String
  creationDate: String!
  defaultSingletonActionHolder: Boolean!
  deferDate: String
  dropped: Boolean!
  droppedDate: String
  dueDate: String
  effectiveDeferDate: String
  effectiveDueDate: String
  effectivelyCompleted: Boolean!
  effectivelyDropped: Boolean!
  estimatedMinutes: Int
  flagged: Boolean!
  folder: Folder
  id: String!
  lastReviewDate: String!
  modificationDate: String!
  name: String!
  nextDeferDate: String
  nextDueDate: String
  nextReviewDate: String
  nextTask: Task
  numberOfAvailableTasks: Int!
  numberOfCompletedTasks: Int!
  numberOfTasks: Int!
  primaryTag: Tag
  rootTask: Task!
  sequential: Boolean!
  shouldUseFloatingTimeZone: Boolean!
  singletonActionHolder: Boolean!
}

type ProjectConnection implements Connection {
  byId(id: String!): Project
  edges: [ProjectEdge!]!
  pageInfo: PageInfo!
}

type ProjectEdge implements Edge {
  cursor: String!
  node: Project!
}

type Query {
  defaultDocument: Document!
}

type Section implements Node {
  id: String!
  name: String!
}

type SectionConnection implements Connection {
  byId(id: String!): Section
  edges: [SectionEdge!]!
  pageInfo: PageInfo!
}

type SectionEdge implements Edge {
  cursor: String!
  node: Section!
}

type Tag implements Node {
  allowsNextAction: Boolean!
  availableTaskCount: Int!
  effectivelyHidden: Boolean!
  hidden: Boolean!
  id: String!
  name: String!
  remainingTaskCount: Int!
  tags: TagConnection!
  tasks: TaskConnection!
}

type TagConnection implements Connection {
  byId(id: String!): Tag
  edges: [TagEdge!]!
  pageInfo: PageInfo!
}

type TagEdge implements Edge {
  cursor: String!
  node: Tag!
}

interface TaskInterface implements Node {
  blocked: Boolean!
  completed: Boolean!
  completedByChildren: Boolean!
  completionDate: String
  containingProject: Project
  creationDate: String!
  deferDate: String
  dropped: Boolean!
  droppedDate: String
  dueDate: String
  effectiveDeferDate: String
  effectiveDueDate: String
  effectivelyCompleted: Boolean!
  effectivelyDropped: Boolean!
  estimatedMinutes: Int
  flagged: Boolean!
  flattenedTasks: FlattenedTaskConnection!
  id: String!
  inInbox: Boolean!
  modificationDate: String!
  name: String!
  next: Boolean!
  nextDeferDate: String
  nextDueDate: String
  numberOfAvailableTasks: Int!
  numberOfCompletedTasks: Int!
  numberOfTasks: Int!
  parentTask: Task
  primaryTag: Tag
  sequential: Boolean!
  shouldUseFloatingTimeZone: Boolean!
  tags: TagConnection!
  tasks: TaskConnection!
}

type Task implements Node & TaskInterface {
  blocked: Boolean!
  completed: Boolean!
  completedByChildren: Boolean!
  completionDate: String
  containingProject: Project
  creationDate: String!
  deferDate: String
  dropped: Boolean!
  droppedDate: String
  dueDate: String
  effectiveDeferDate: String
  effectiveDueDate: String
  effectivelyCompleted: Boolean!
  effectivelyDropped: Boolean!
  estimatedMinutes: Int
  flagged: Boolean!
  flattenedTasks: FlattenedTaskConnection!
  id: String!
  inInbox: Boolean!
  modificationDate: String!
  name: String!
  next: Boolean!
  nextDeferDate: String
  nextDueDate: String
  numberOfAvailableTasks: Int!
  numberOfCompletedTasks: Int!
  numberOfTasks: Int!
  parentTask: Task
  primaryTag: Tag
  sequential: Boolean!
  shouldUseFloatingTimeZone: Boolean!
  tags: TagConnection!
  tasks: TaskConnection!
}

type TaskConnection implements Connection {
  byId(id: String!): Task
  edges: [TaskEdge!]!
  pageInfo: PageInfo!
}

type TaskEdge implements Edge {
  cursor: String!
  node: Task!
}
